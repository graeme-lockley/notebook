# ObservableHQ Clone - Development Rules

## Project Overview

This is an ObservableHQ clone built with **SvelteKit**, **TypeScript**, and **Event Sourcing**. The architecture follows **Clean Architecture** principles with **CQRS**, **Domain-Driven Design**, and a **lazy-loading projection system** for optimal memory efficiency.

**Architecture Score: 93/100**

---

## Clean Architecture Principles

### Layer Structure

```
routes/ (Interface/Presentation)
    ↓ depends on
application/ (Use Cases & Services)
    ↓ depends on
domain/ (Business Logic - PURE)
    ↓ no dependencies
[Event Store - External Service]
```

### Dependency Rule

**CRITICAL:** Dependencies ONLY point inward. Outer layers depend on inner layers, never the reverse.

- ✅ Routes can depend on Application
- ✅ Application can depend on Domain
- ❌ Domain NEVER depends on Application or Infrastructure
- ❌ Domain NEVER imports from `infrastructure/`, `adapters/`, or `routes/`

### Domain Layer Purity

**The domain layer MUST be 100% pure:**

- ❌ NO imports from `$lib/common/infrastructure/`
- ❌ NO logger, database, or external service dependencies
- ❌ NO side effects in domain services
- ✅ Pure business logic only
- ✅ Event creation (stateless)
- ✅ Value objects and entities

**Example - CORRECT Domain Service:**

```typescript
// ✅ domain/domain-services/library.service.impl.ts
export class LibraryServiceImpl {
	createNotebookEvent(title: string): NotebookCreatedEvent {
		// Pure event creation - no logging, no side effects
		return {
			type: 'notebook.created',
			payload: { notebookId: generateId(), title }
		};
	}
}
```

**Example - INCORRECT Domain Service:**

```typescript
// ❌ DO NOT DO THIS
import { logger } from '$lib/common/infrastructure/logging/logger.service';

export class LibraryServiceImpl {
	createNotebookEvent(title: string): NotebookCreatedEvent {
		logger.info('Creating notebook'); // ❌ WRONG - infrastructure in domain
		return { type: 'notebook.created', payload: { ... } };
	}
}
```

---

## Event Sourcing & CQRS

### Event Sourcing

All state changes are captured as immutable events stored in the Event Store:

- **Commands** create events (write side)
- **Projections** build read models from events (read side)
- **Event Store** is the single source of truth
- Events are immutable and append-only
- Complete audit trail built-in

### CQRS Pattern

**Clear separation between Commands (writes) and Queries (reads):**

**Commands (Write Side):**

```typescript
// Command Handler creates events
export class AddCellCommandHandler {
	async handle(command: AddCellCommand): Promise<{ cellId: string }> {
		// 1. Validate using projection
		const readModel = await projectionManager.getProjectionReadModel(notebookId);

		// 2. Create event (stateless)
		const event = NotebookEventFactory.createCellEvent(...);

		// 3. Publish to event store
		await eventStore.publishEvent(event);

		// 4. Publish to event bus (for projectors)
		await eventBus.publish(event);

		return { cellId: event.payload.cellId };
	}
}
```

**Queries (Read Side):**

```typescript
// Query uses read model (projection)
export async function GET({ params, locals }) {
	const readModel = await locals.projectionManager.getProjectionReadModel(params.notebookId);
	const cells = await readModel.getCells(params.notebookId);
	return json({ cells });
}
```

### Event-First Development

When implementing new features:

1. Define domain events first
2. Create event factory methods
3. Build projectors to handle events
4. Implement command handlers
5. Create API endpoints

---

## Projection Manager Architecture

### Lazy Loading Pattern

**Notebooks are loaded on-demand, not at startup:**

```typescript
// ❌ OLD: Eager loading (all notebooks at startup)
// await hydrateReadModels(notebookReadModel); // DON'T DO THIS

// ✅ NEW: Lazy loading (on-demand)
await projectionManager.acquireProjection(notebookId); // Load when needed
```

### Reference Counting

**Projections are shared and reference-counted:**

```typescript
// User A connects → refCount = 1, hydrate projection
await projectionManager.acquireProjection(notebookId);

// User B connects → refCount = 2, reuse existing projection
await projectionManager.acquireProjection(notebookId);

// User A disconnects → refCount = 1, keep projection
await projectionManager.releaseProjection(notebookId);

// User B disconnects → refCount = 0, start 60s grace period
await projectionManager.releaseProjection(notebookId);
```

### Grace Period (60 seconds)

After the last reference is released:

- Start 60-second timer before eviction
- Allows quick reconnects without re-hydration
- Cancels timer if re-acquired during grace period
- Evicts projection after timer expires

### Event Streaming

Projections stay current via event streaming:

```typescript
// After hydration, stream new events
for await (const event of eventStore.streamEvents(notebookId, {
	sinceEventId: lastProcessedEventId
})) {
	await projector.handle(event);
}
```

### When to Use Projection Manager

**Always use `withProjection` middleware in REST API:**

```typescript
// ✅ CORRECT: Acquire and release pattern
export async function GET({ params, locals }) {
	return withProjection(params.notebookId, locals.projectionManager, async (readModel) => {
		const cells = await readModel.getCells(params.notebookId);
		return json({ cells });
	});
}

// ❌ WRONG: Direct access without acquire/release
export async function GET({ params, locals }) {
	const readModel = await locals.projectionManager.getProjectionReadModel(params.notebookId);
	// Missing acquire/release!
	return json({ cells: await readModel.getCells(params.notebookId) });
}
```

**WebSocket connections automatically acquire/release:**

```typescript
// SvelteKitWebSocketService handles this automatically
async addConnection(connection: WebSocketConnection): Promise<void> {
	await this.projectionManager.acquireProjection(connection.notebookId);
	// Connection added...
}

async removeConnection(connectionId: string): Promise<void> {
	// Connection removed...
	await this.projectionManager.releaseProjection(connection.notebookId);
}
```

---

## Port & Adapter Pattern

### Ports (Interfaces)

Define contracts in `application/ports/`:

```typescript
// ports/inbound/read-models.ts
export interface CellReadModel {
	getCells(notebookId: string): Promise<Cell[]>;
	getCell(notebookId: string, cellId: string): Promise<Cell | null>;
}

// ports/outbound/event-store.ts
export interface EventStore {
	publishEvent(event: DomainEvent): Promise<string>;
	streamEvents(topic: string, options: StreamOptions): AsyncIterable<DomainEvent>;
}
```

### Adapters (Implementations)

Implement ports in `application/adapters/`:

```typescript
// adapters/inbound/per-notebook-read-model.ts
export class PerNotebookReadModel implements CellReadModel {
	async getCells(notebookId: string): Promise<Cell[]> {
		return this.cells; // Implementation
	}
}

// adapters/outbound/event-store/remote/
export class RemoteEventStore implements EventStore {
	async publishEvent(event: DomainEvent): Promise<string> {
		// HTTP call to Event Store
	}
}
```

### Dependency Injection

Services receive dependencies via constructor:

```typescript
export class NotebookCommandService {
	constructor(
		private eventStore: EventStore, // Port (interface)
		private projectionManager: NotebookProjectionManager,
		private eventBus: EventBus
	) {}
}
```

---

## Interface Segregation Principle

### Focused Interfaces

**Split large interfaces into focused, single-purpose interfaces:**

```typescript
// ✅ CORRECT: Focused interfaces
export interface CellReadModel {
	getCells(notebookId: string): Promise<Cell[]>;
	getCell(notebookId: string, cellId: string): Promise<Cell | null>;
}

export interface CellWriteModel {
	addCellAtPosition(notebookId: string, cell: Cell, position: number): void;
	updateCell(notebookId: string, cellId: string, updatedCell: Cell): void;
	removeCell(notebookId: string, cellId: string): void;
	moveCell(notebookId: string, cellId: string, newPosition: number): void;
}

// Combine when both are needed
export interface PerNotebookReadModelInterface extends CellReadModel, CellWriteModel {}
```

**Benefits:**

- Clients depend only on methods they use
- No no-op methods
- Clear intent and responsibilities
- Easy to test

---

## Command Handlers (Use Cases)

### Pattern

Command handlers implement use cases and follow a consistent pattern:

```typescript
export class AddCellCommandHandler {
	constructor(
		private eventStore: EventStore,
		private projectionManager: NotebookProjectionManager,
		private eventBus: EventBus
	) {}

	async handle(command: AddCellCommand): Promise<AddCellCommandResult> {
		// 1. Acquire projection for validation
		await this.projectionManager.acquireProjection(command.notebookId);

		try {
			// 2. Get read model for validation
			const readModel = await this.projectionManager.getProjectionReadModel(command.notebookId);

			// 3. Validate command using projection state
			// ... validation logic ...

			// 4. Create event (stateless factory)
			const event = NotebookEventFactory.createCellEvent(
				command.notebookId,
				command.kind,
				command.value,
				command.position
			);

			// 5. Publish to event store (persistence)
			const eventId = await this.eventStore.publishEvent(
				command.notebookId,
				event.type,
				event.payload
			);

			// 6. Publish to event bus (for projectors)
			await this.eventBus.publish({
				...event,
				id: eventId,
				aggregateId: command.notebookId
			});

			return { cellId: event.payload.cellId, eventId };
		} finally {
			// 7. Always release projection
			await this.projectionManager.releaseProjection(command.notebookId);
		}
	}
}
```

### Key Points

- Use projection manager for validation (single source of truth)
- Create events via stateless factory
- Publish to event store (persistence)
- Publish to event bus (projectors update read models)
- Always release projection (finally block)

---

## Stateless Event Factories

### Pattern

Event creation should be stateless and pure:

```typescript
// ✅ CORRECT: Stateless event factory
export class NotebookEventFactory {
	static createCellEvent(
		notebookId: string,
		kind: CellKind,
		value: string,
		position: number
	): CellCreatedEvent {
		return {
			type: 'cell.created',
			payload: {
				cellId: generateCellId(),
				notebookId,
				kind,
				value,
				position,
				createdAt: new Date().toISOString()
			}
		};
	}

	static createUpdateCellEvent(...): CellUpdatedEvent {
		// Pure event creation
	}
}

// ❌ WRONG: Stateful domain service
export class NotebookServiceImpl {
	private _cells: Cell[] = []; // ❌ No state in domain!

	createCellEvent(...) {
		this._cells.push(cell); // ❌ Don't mutate state!
		return event;
	}
}
```

---

## File Organization

### Server Architecture

```
src/lib/server/
├── adapters/                   # Infrastructure implementations
│   └── outbound/
│       └── event-store/       # Event Store adapters
│           ├── inmemory/      # In-memory (testing)
│           └── remote/        # Remote Event Store
│
├── application/                # Application Layer
│   ├── adapters/              # More adapters
│   │   ├── inbound/           # Read models, projectors
│   │   │   ├── per-notebook-read-model.ts
│   │   │   └── in-memory-library-read-model.ts
│   │   └── outbound/          # Event bus, WebSocket
│   │       ├── simple-event-bus.ts
│   │       └── sveltekit-websocket-service.ts
│   │
│   ├── command-handlers/      # Use cases (commands)
│   │   ├── add-cell-command-handler.ts
│   │   ├── update-cell-command-handler.ts
│   │   ├── delete-cell-command-handler.ts
│   │   └── move-cell-command-handler.ts
│   │
│   ├── middleware/            # Cross-cutting concerns
│   │   └── projection-middleware.ts
│   │
│   ├── ports/                 # Interface definitions
│   │   ├── inbound/           # Incoming adapters
│   │   │   └── read-models.ts
│   │   └── outbound/          # Outgoing adapters
│   │       ├── event-store.ts
│   │       ├── event-bus.ts
│   │       └── websocket-service.ts
│   │
│   ├── projectors/            # Event → Read Model
│   │   ├── notebook-projector.ts
│   │   ├── library-projector.ts
│   │   └── websocket-projector.ts
│   │
│   └── services/              # Application services
│       ├── notebook-projection-manager.ts  # KEY SERVICE
│       ├── notebook-command.service.ts     # Command facade
│       ├── notebook-event-factory.ts       # Event factory
│       ├── library-application-service.ts
│       └── projection-manager-config.ts
│
├── domain/                    # Domain Layer (PURE!)
│   ├── domain-services/       # Business logic (pure)
│   │   ├── library.domain-service.ts
│   │   ├── library.service.impl.ts
│   │   └── library.ts
│   │
│   ├── events/                # Domain event types
│   │   └── notebook.events.ts
│   │
│   └── value-objects/         # Domain entities
│       ├── cell.ts
│       ├── notebook.ts
│       └── ...
│
└── websocket/                 # WebSocket server
    └── sveltekit-websocket-server.ts
```

### Naming Conventions

- **Command Handlers:** `*-command-handler.ts` (use cases)
- **Services:** `*.service.ts` or `*.service.impl.ts`
- **Projectors:** `*-projector.ts`
- **Read Models:** `*-read-model.ts`
- **Event Factories:** `*-event-factory.ts`
- **Ports:** Interface definitions in `ports/`
- **Adapters:** Implementations in `adapters/`

---

## Testing Requirements

### Test-First Development (TDD)

1. Write test first
2. Make it fail
3. Write minimal code to pass
4. Refactor
5. Repeat

### Test Coverage Requirements

- **Domain Services:** 100% coverage (pure, easy to test)
- **Command Handlers:** 95%+ coverage
- **Projectors:** 95%+ coverage
- **Application Services:** 90%+ coverage
- **Integration Tests:** Critical paths

### Testing Patterns

**Unit Tests (Vitest):**

```typescript
describe('AddCellCommandHandler', () => {
	let handler: AddCellCommandHandler;
	let eventStore: MockEventStore;
	let projectionManager: MockProjectionManager;
	let eventBus: MockEventBus;

	beforeEach(() => {
		eventStore = createMockEventStore();
		projectionManager = createMockProjectionManager();
		eventBus = createMockEventBus();
		handler = new AddCellCommandHandler(eventStore, projectionManager, eventBus);
	});

	it('should create cell and publish events', async () => {
		const result = await handler.handle({
			notebookId: 'test-notebook',
			kind: 'javascript',
			value: 'console.log("hello")',
			position: 0
		});

		expect(result.cellId).toBeDefined();
		expect(eventStore.publishEvent).toHaveBeenCalledWith(
			'test-notebook',
			'cell.created',
			expect.any(Object)
		);
		expect(eventBus.publish).toHaveBeenCalled();
	});
});
```

**Integration Tests:**

```typescript
describe('Notebook Projection Lifecycle', () => {
	it('should load projection on acquire and evict after grace period', async () => {
		// Acquire projection
		await projectionManager.acquireProjection('notebook-1');

		// Verify it's loaded
		const readModel = await projectionManager.getProjectionReadModel('notebook-1');
		expect(readModel).toBeDefined();

		// Release projection
		await projectionManager.releaseProjection('notebook-1');

		// Wait for grace period (60s)
		await wait(60000);

		// Verify it's evicted
		const readModelAfter = await projectionManager.getProjectionReadModel('notebook-1');
		expect(readModelAfter).toBeNull();
	});
});
```

---

## API Route Patterns

### REST API with Projection Middleware

Always use `withProjection` middleware:

```typescript
// GET endpoint
export async function GET({ params, locals }: RequestEvent) {
	return withProjection(params.notebookId, locals.projectionManager, async (readModel) => {
		const cells = await readModel.getCells(params.notebookId);
		return json({ cells });
	});
}

// POST endpoint (command)
export async function POST({ params, request, locals }: RequestEvent) {
	const body = await request.json();

	// Validate notebook exists
	const notebook = locals.libraryService.getNotebook(params.notebookId);
	if (!notebook) {
		return json({ error: 'Notebook not found' }, { status: 404 });
	}

	// Execute command via service
	const result = await locals.notebookCommandService.addCell(
		params.notebookId,
		body.kind,
		body.value,
		body.position
	);

	return json(
		{
			message: 'Cell added successfully',
			cellId: result.cellId,
			eventId: result.eventId
		},
		{ status: 201 }
	);
}
```

### WebSocket Endpoint

```typescript
export async function GET({ params, locals, request }: RequestEvent) {
	const { notebookId } = params;

	// Get initial state using projection
	const initialState = await withProjection(
		notebookId,
		locals.projectionManager,
		async (readModel) => {
			const cells = await readModel.getCells(notebookId);
			return { notebookId, cells };
		}
	);

	// Setup WebSocket connection
	// Connection lifecycle automatically acquires/releases projection
}
```

---

## TypeScript Conventions

### Strict Mode

Always use TypeScript strict mode:

```json
{
	"compilerOptions": {
		"strict": true,
		"noImplicitAny": true,
		"strictNullChecks": true
	}
}
```

### Type Annotations

Always add explicit types:

```typescript
// ✅ CORRECT: Explicit types
async function getCells(notebookId: string): Promise<Cell[]> {
	return this.cells.filter((c) => c.notebookId === notebookId);
}

// ❌ WRONG: Implicit types
async function getCells(notebookId) {
	return this.cells.filter((c) => c.notebookId === notebookId);
}
```

### Interfaces vs Types

- Use **interfaces** for object shapes
- Use **types** for unions, intersections, primitives

```typescript
// ✅ Interface for object shape
export interface Cell {
	id: string;
	kind: CellKind;
	value: string;
}

// ✅ Type for union
export type CellKind = 'javascript' | 'markdown' | 'html';
```

---

## Code Style

### SvelteKit Conventions

- Use `+page.svelte` for page components
- Use `+server.ts` for API endpoints
- Use `$lib` alias for imports
- Keep routes thin (delegate to services)

### Formatting

- Run `prettier --write .` before committing
- Use tabs for indentation (project standard)
- 100-character line length
- Trailing commas in multiline

### Imports

Organize imports by source:

```typescript
// 1. External dependencies
import { json } from '@sveltejs/kit';
import type { RequestEvent } from '@sveltejs/kit';

// 2. Internal $lib imports
import { logger } from '$lib/common/infrastructure/logging/logger.service';

// 3. Relative imports
import type { Cell } from '../domain/value-objects';
```

---

## Performance Considerations

### Memory Efficiency

- Lazy load projections (not eager)
- Use reference counting
- Implement grace period for quick reconnects
- Monitor projection count in production

### Event Streaming

- Stream events (don't poll)
- Continue from last processed event
- Use AbortController for cleanup

### Optimization

- Profile memory usage regularly
- Monitor projection lifecycle
- Log projection metrics
- Set up alerts for high memory usage

---

## Error Handling

### Application Layer

Application layer handles errors and logging:

```typescript
export class NotebookCommandService {
	async addCell(...args): Promise<Result> {
		logger.info(`Adding cell to notebook ${notebookId}`); // ✅ Logging in application

		try {
			const result = await handler.handle(...);
			logger.info(`Cell added successfully: ${result.cellId}`);
			return result;
		} catch (error) {
			logger.error('Error adding cell:', error);
			throw error;
		}
	}
}
```

### Domain Layer

Domain layer throws domain exceptions (no logging):

```typescript
export class LibraryServiceImpl {
	createNotebookEvent(title: string): NotebookCreatedEvent {
		if (!title || title.trim() === '') {
			throw new Error('Title is required'); // ✅ Domain exception
		}
		return { type: 'notebook.created', payload: { ... } };
	}
}
```

---

## ObservableHQ Specific UI

### UI Patterns

- Output above editor (key ObservableHQ pattern)
- Left gutter with focus highlight
- Top-right run icon in editors
- "+" add cell affordances between cells
- Auto-resizing editors (CodeMirror 6)

### Animation Guidelines

- Use 120-200ms for micro-animations
- Smooth focus transitions
- Hover/focus reveal animations

---

## Git Workflow

### Before Committing

1. Run `npm run lint` (must pass)
2. Run `npm run test:unit` (all tests pass)
3. Run `prettier --write .` (format code)
4. Verify TypeScript compiles without errors

### Commit Messages

Use conventional commit format:

```
feat: add lazy loading for notebook projections
fix: resolve race condition in projection manager
refactor: extract event factory from domain service
docs: update architecture documentation
test: add integration tests for projection lifecycle
```

---

## Architecture Documentation

**Primary Reference:** `docs/ARCHITECTURE.md` (1,246 lines)

- Complete system architecture
- Architectural evolution (chronological)
- Design decisions and rationale
- Core component details
- Performance characteristics
- Future recommendations

**Quick Guide:** `docs/README_ARCHITECTURE.md`

- Quick-start for developers
- Quick-start for AI agents
- Navigation help

**Update Documentation When:**

- Making architectural changes
- Adding new patterns
- Changing design decisions
- Refactoring major components

---

## Key Takeaways

1. **Domain is Pure** - No infrastructure dependencies
2. **Lazy Loading** - Projections loaded on-demand with reference counting
3. **CQRS** - Clear separation of commands and queries
4. **Event Sourcing** - All state changes as events
5. **Clean Architecture** - Dependency rule strictly enforced
6. **Stateless Factories** - Event creation is pure and stateless
7. **Interface Segregation** - Focused, single-purpose interfaces
8. **Projection Manager** - Single source of truth for read models
9. **Test-First** - Write tests before implementation
10. **Documentation** - Keep `docs/ARCHITECTURE.md` updated

---

**Architecture Score: 93/100** - Excellent architecture with clean separation of concerns, domain purity, and efficient resource management.
